**Hybrid approaches**. Sorts in **library implementations** usually combine **multiple** algorithms (e.g. **insertion** sort for **small** inputs, **improved** versions of **quick** sort or **merge** sort for **large** inputs).
| algorithm       | Stable | In-place | Time(worst)     | time(average)   | Time(best)        | Space   | Properties                                                                                                                                                                                     |
| --------------- | ------ | -------- | --------------- | --------------- | ----------------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Selection       | yes    | yes      | $O(n^2)$        | $O(n^2)$        | $O(n^2)$          | O(1)    | Slow. In-place. For small datasets (< 1K).                                                                                                                                                     |
| insertion       | yes    | yes      | $O(n^2)$        | $O(n^2)$        | $O(n)$            | O(1)    | Generally slow. In-place. For small datasets (< 1K). Can be O (n) time for nearly sorted sequences.                                                                                            |
| [[Heap sort]]   | no     | yes      | O($n\log_2(n)$) | O($n\log_2(n)$) | O($n\log_2(n)$)'  | O($n$)  | Fast. In-place. For large datasets (1K - 1M). 'Best O (n) time only if all elements are equal!                                                                                                 |
| [[Quick sort]]  | no     | yes      | $O(n^2)$        | O($n\log_2(n)$) | O($n\log_2(n)$)   | O(1)    | In-place. Randomized. Fastest (good for large inputs). Worst-case O($n^2$).                                                                                                                    |
| [[Merge sort]]  | yes    | no       | O($n\log_2(n)$) | O($n\log_2(n)$) | O($n\log_2(n)$)'' | O(n)''' | Fast. Sequential data access. For huge data sets (> 1M). ''Can be made to have best (n) time, but only if sequence is sorted. '''Difficult to implement in-place, beyond scope of this course. |
| [[Radix sort]]  | yes    | no       | O(d(n+N))       | O(d(n+N))       | O(d(n+N))         | O(n+N)  | Integers, strings, other d-tuples. If d(n + N) Â« n logn, radix are faster than comparison-based algorithms.                                                                                    |
| [[Bucket sort]] | yes    | no       | O(n)            | O(n)            | O(n)              | O(N)    |                                                                                                                                                                                                |


