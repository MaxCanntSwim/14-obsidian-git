Maps map values to a nother value, 
```java
public interface Map<K, V> {
	int size();
	boolean isEmpty ();
	V get (K key);
	V put (K key, V value);
	V remove (K key);
	/* more operations in the book */
}
```
![[Screenshot 2023-01-08 at 15.17.27.jpg]]
there are ways to deal with collisions: 
- **Separate** chaining: have a **secondary** container/ map in each **bucket**
- **Open** addressing: **reuse** other **free** buckets when collisions occur

# Hash functions
To calculate some integer from the information provided. 
## components
### HashCode
This calculates an int from the key. 
### Compress
This will display the results. 
### Conclusion
| name     | opperation      | result                             |
| -------- | --------------- | ---------------------------------- |
| hashCode | Key -> int      | Ruby -> 62(sum int of the letters) |
| compress | int -> {0, N-1} | 62 -> 10 (modulus 26)                                   |

It is smart to split these two functions because, if it turns out you need a different modulus in the compress, you are able to only change the compress. 
## Separate Chaining
Separate Chaining is the **collision resolution technique that is implemented using linked list**. When two or more elements are hash to the same location, these elements are represented into a singly-linked list like a chain.

## Linear probing
The simplest approach to resolve a collision is **linear probing**. In this technique, if a value is **already** **stored** at a location generated by **h(k)**, it means **collision** **occurred** then we do a **sequential** search to find the **empty** location.

Here the idea is to place a **value** in the **next available position**. Because in this approach searches are **performed** **sequentially** so it’s known as linear probing.

Here **array** or **hash** **table** is **considered** **circular** because when the last slot reached an empty location not found then the search proceeds to the first location of the array.